/**
 *
 */
import Util;
import EventBridgeUtil;
import Credential;

type @protocol = string
type @readTimeout = integer
type @connectTimeout = integer
type @httpProxy = string
type @httpsProxy = string
type @noProxy = string
type @maxIdleConns = integer
type @endpoint = string
type @regionId = string
type @credential = Credential

/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  regionId?: string(description='region id',example='cn-hangzhou',default='',pattern='^[a-zA-Z0-9_-]+$'),
  readTimeout?: integer(description='read timeout',example='10',default=''),
  connectTimeout?: integer(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  credential?: Credential(description='credential',example='',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: integer(description='max idle conns',example='3',default=''),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config){
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  Util.validateModel(config);
  if(!Util.empty(config.accessKeyId) && !Util.empty(config.accessKeySecret)){
    var credentialType = 'access_key';
    if (!Util.empty(config.securityToken)) {
      credentialType = 'sts';
    }

    var credentialConfig = new Credential.Config{
      accessKeyId = config.accessKeyId,
      type = credentialType,
      accessKeySecret = config.accessKeySecret,
      securityToken = config.securityToken
    };
    @credential = new Credential(credentialConfig);
  } else if(!Util.isUnset(config.credential)) {
    @credential = config.credential;
  } else {
    throw {
      code = 'ParameterMissing',
      message = '\'accessKeyId\' and \'accessKeySecret\' or \'credential\' can not be unset'
    };
  }
  if (Util.empty(config.endpoint)) {
    throw {
      code = 'ParameterMissing',
      message = '\'endpoint\' can not be unset'
    };
  }

  if (EventBridgeUtil.startWith(config.endpoint, 'http') || EventBridgeUtil.startWith(config.endpoint, 'https')) {
    throw {
      code = 'ParameterError',
      message = '\'endpoint\' shouldn\'t start with \'http\' or \'https\''
    };
  }
  @regionId = config.regionId;
  @protocol = config.protocol;
  @endpoint = config.endpoint;
  @readTimeout = config.readTimeout;
  @connectTimeout = config.connectTimeout;
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @maxIdleConns = config.maxIdleConns;
}

/**
 * The detail of put event result
 */
model PutEventsResponseEntry {
  eventId?: string(name='EventId'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
}

/**
 * Cloud Event Stanard Froamt
 */
model CloudEvent {
  id: string(name='id'),
  source: string(name='source', maxLength=128),
  specversion?: string(name='specversion'),
  type: string(name='type', maxLength=64),
  datacontenttype?: string(name='datacontenttype'),
  dataschema?: string(name='dataschema'),
  subject?: string(name='subject'),
  time?: string(name='time', maxLength=64, pattern='[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}[\\\\s\\\\S]*'),
  extensions: map[string]any(name='extensions'),
  data?: bytes(name='data'),
}

/**
 * put event response
 */
model PutEventsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  failedEntryCount?: integer(name='FailedEntryCount'),
  entryList?: [ PutEventsResponseEntry ](name='EntryList'),
}

/**
 * Publish event to the aliyun EventBus
 */
async function putEvents(eventList: [ CloudEvent ]): PutEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventsWithOptions(eventList, runtime);
}

/**
 * Publish event to the aliyun EventBus
 */
async function putEventsWithOptions(eventList: [ CloudEvent ], runtime: Util.RuntimeOptions): PutEventsResponse {
  for (var cloudEvent : eventList) {
    if (Util.isUnset(cloudEvent.specversion)) {
      cloudEvent.specversion = '1.0';
    }

    if (Util.isUnset(cloudEvent.datacontenttype)) {
      cloudEvent.datacontenttype = 'application/json; charset=utf-8';
    }
    Util.validateModel(cloudEvent);
  }
  var body = EventBridgeUtil.serialize(eventList);
  return doRequest('putEvents', 'HTTP', 'POST', `/openapi/putEvents`, null, body, null, runtime);
}

/**
 * Publish event to the aliyun specified account's event bus
 */
async function putEventsToAccount(accoutid: string, eventList: [ CloudEvent ]): PutEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventsToAccountWithOptions(accoutid, eventList, runtime);
}

/**
 * Publish event to the aliyun specified account's event bus
 */
async function putEventsToAccountWithOptions(accoutid: string, eventList: [ CloudEvent ], runtime: Util.RuntimeOptions): PutEventsResponse {
  for (var cloudEvent : eventList) {
    if (Util.isUnset(cloudEvent.specversion)) {
      cloudEvent.specversion = '1.0';
    }

    if (Util.isUnset(cloudEvent.datacontenttype)) {
      cloudEvent.datacontenttype = 'application/json; charset=utf-8';
    }
    Util.validateModel(cloudEvent);
  }
  if (Util.empty(accoutid)) {
    throw {
      code = 'ParameterMissing',
      message = 'accoutid should be setted',
    };
  }
  
  var header : map[string]string = {
    x-eventbridge-accountid = accoutid,
  };
  var body = EventBridgeUtil.serialize(eventList);
  return doRequest('putEventsToAccount', 'HTTP', 'POST', `/openapi/putEventsToAccount`, null, body, header,runtime);
}

/**
 * The request of create EventBus
 */
model CreateEventBusRequest = {
  eventBusName: string(name='EventBusName', maxLength=127, minLength=1),
  description?: string(name='Description'),
}

/**
 * The response of create EventBus
 */
model CreateEventBusResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventBusARN?: string(name='EventBusARN'),
}

/**
 * Creates a new event bus within your account. This can be a custom event bus which you can use to receive events from your custom applications and services
 */
async function createEventBus(request: CreateEventBusRequest): CreateEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventBusWithOptions(request, runtime);
}

/**
 * Creates a new event bus within your account. This can be a custom event bus which you can use to receive events from your custom applications and services
 */
async function createEventBusWithOptions(request: CreateEventBusRequest, runtime: Util.RuntimeOptions): CreateEventBusResponse {
  Util.validateModel(request);
  return doRequest('createEventBus', 'HTTP', 'POST', `/openapi/createEventBus`, null, request, null, runtime);
}

/**
 * The event source entry
 */
model EBAliyunOfficialEventSourceEntry = {
  name: string(name='Name'),
  description: string(name='Description'),
  arn: string(name='ARN'),
  status: string(name='Status'),
  ctime: long(name='Ctime'),
  eventBusName: string(name='EventBusName'),
  eventTypes: [ EventTypeEntry ](name='EventTypes'),
}

/**
 * The event source entry
 */
model EventTypeEntry = {
  name: string(name='Name'),
  eventSourceName: string(name='EventSourceName'),
  shortName: string(name='ShortName'),
  groupName: string(name='GroupName'),
}

/**
 * The request of listAliyunOfficialEventSources
 */
model ListAliyunOfficialRequest = {
  nextToken?: string(name='NextToken'),
  limit?: integer(name='Limit'),
}

/**
 * The response of listAliyunOfficialEventSources
 */
model ListAliyunOfficialResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventSourceList: [ EBAliyunOfficialEventSourceEntry ](name='EventSourceList'),
  nextToken: string(name='NextToken'),
  total: integer(name='Total'),
}

/**
 * List the aliyun official event source within your account
 */
async function listAliyunOfficialEventSources(request: ListAliyunOfficialRequest): ListAliyunOfficialResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAliyunOfficialEventSourcesWithOptions(request, runtime);
}

/**
 * List the aliyun official event source within your account
 */
async function listAliyunOfficialEventSourcesWithOptions(request: ListAliyunOfficialRequest, runtime: Util.RuntimeOptions): ListAliyunOfficialResponse {
  Util.validateModel(request);
  return doRequest('listAliyunOfficialEventSources', 'HTTP', 'POST', `/openapi/v2/listAliyunOfficialEventSources`, null, request, null, runtime);
}

/**
 * The event source entry
 */
model EBUserDefinedEventSourceEntry = {
  name?: string(name='Name'),
  description?: string(name='Description'),
  arn?: string(name='ARN'),
  status?: string(name='Status'),
  ctime?: long(name='Ctime'),
  eventBusName?: string(name='EventBusName'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='SourceRabbitMQParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='SourceMNSParameters'),
  sourceRocketMQParameters: SourceRocketMQParameters(name='SourceRocketMQParameters'),
  sourceKafkaParameters: SourceKafkaParameters(name='SourceKafkaParameters'),
}

/**
 * The request of listUserDefinedEventSources
 */
model ListUserDefinedRequest = {
  eventBusName?: string(name='EventBusName'),
  nextToken?: string(name='NextToken'),
  limit?: integer(name='Limit'),
}

/**
 * The response of listUserDefinedEventSources
 */
model ListUserDefinedResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventSources?: [ EBUserDefinedEventSourceEntry ](name='EventSources'),
  nextToken?: string(name='NextToken'),
  total?: integer(name='Total'),
}

/**
 * List the user defined event source within your account
 */
async function listUserDefinedEventSources(request: ListUserDefinedRequest): ListUserDefinedResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserDefinedEventSourcesWithOptions(request, runtime);
}

/**
 * List the user defined event source within your account
 */
async function listUserDefinedEventSourcesWithOptions(request: ListUserDefinedRequest, runtime: Util.RuntimeOptions): ListUserDefinedResponse {
  Util.validateModel(request);
  return doRequest('listUserDefinedEventSources', 'HTTP', 'POST', `/openapi/v2/listUserDefinedEventSources`, null, request, null, runtime);
}

/**
 * The request of delete the EventBus
 */
model DeleteEventBusRequest = {
  eventBusName: string(name='EventBusName'),
}

/**
 * The response of delete the EventBus
 */
model DeleteEventBusResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Deletes the specified custom event bus in your account,You can't delete your account's default event bus
 */
async function deleteEventBus(request: DeleteEventBusRequest): DeleteEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventBusWithOptions(request, runtime);
}

/**
 * Deletes the specified custom event bus in your account,You can't delete your account's default event bus
 */
async function deleteEventBusWithOptions(request: DeleteEventBusRequest, runtime: Util.RuntimeOptions): DeleteEventBusResponse {
  Util.validateModel(request);
  return doRequest('deleteEventBus', 'HTTP', 'POST', `/openapi/deleteEventBus`, null, request, null, runtime);
}

/**
 * The request of get the detail of EventBus
 */
model GetEventBusRequest = {
  eventBusName: string(name='EventBusName'),
}

/**
 * The response of get the detail of EventBus
 */
model GetEventBusResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventBusARN: string(name='EventBusARN'),
  eventBusName: string(name='EventBusName'),
  description: string(name='Description'),
  createTimestamp: int64(name='CreateTimestamp'),
}

/**
 * Displays details about an event bus in your account
 */
async function getEventBus(request: GetEventBusRequest): GetEventBusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventBusWithOptions(request, runtime);
}

/**
 * Displays details about an event bus in your account
 */
async function getEventBusWithOptions(request: GetEventBusRequest, runtime: Util.RuntimeOptions): GetEventBusResponse {
  Util.validateModel(request);
  return doRequest('getEventBus', 'HTTP', 'POST', `/openapi/getEventBus`, null, request, null, runtime);
}

/**
 * The request of list all the EventBus which meet the search criteria
 */
model ListEventBusesRequest = {
  namePrefix?: string(name='NamePrefix'),
  limit?: integer(name='Limit'),
  nextToken?: string(name='NextToken'),
}

/**
 * The detail of EventBuses
 */
model EventBusEntry = {
  eventBusName: string(name='EventBusName'),
  eventBusARN: string(name='EventBusARN'),
  description: string(name='Description'),
  createTimestamp: int64(name='CreateTimestamp'),
}

/**
 * The response of search EventBus
 */
model ListEventBusesResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventBuses: [ EventBusEntry ](name='EventBuses'),
  nextToken: string(name='NextToken'),
  total: integer(name='Total'),
}

/**
 * List all the EventBus in your account, including the default event bus, custom event buses, which meet the search criteria.
 */
async function listEventBuses(request: ListEventBusesRequest): ListEventBusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventBusesWithOptions(request, runtime);
}

/**
 * List all the EventBus in your account, including the default event bus, custom event buses, which meet the search criteria.
 */
async function listEventBusesWithOptions(request: ListEventBusesRequest, runtime: Util.RuntimeOptions): ListEventBusesResponse {
  Util.validateModel(request);
  return doRequest('listEventBuses', 'HTTP', 'POST', `/openapi/listEventBuses`, null, request, null, runtime);
}

/**
 * The request of create an EventBus rule on Aliyun
 */
model CreateRuleRequest = {
  eventBusName: string(name='EventBusName', maxLength=127, minLength=1),
  description?: string(name='Description'),
  ruleName: string(name='RuleName'),
  status?: string(name='Status'),
  filterPattern?: string(name='FilterPattern'),
  targets: [ TargetEntry ](name='Targets'),
}

/**
 * The traced event
 */
model TracedEvent = {
  eventBusName: string(name='EventBusName'),
  eventId: string(name='EventId'),
  eventSource: string(name='EventSource'),
  eventReceivedTime: long(name='EventReceivedTime'),
}

/**
 * The request of query the event by id
 */
model QueryEventByEventIdRequest = {
  eventBusName?: string(name='EventBusName'),
  eventSource?: string(name='EventSource'),
  eventId?: string(name='EventId'),
}

/**
 * The response of query event by id
 */
model QueryEventByEventIdResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  tracedEvents?: [ TracedEvent ](name='TracedEvents'),
  nextToken?: string(name='NextToken'),
  total?: integer(name='Total'),
}

/**
 * Query the event traces by the event Id
 */
async function queryEventByEventId(request: QueryEventByEventIdRequest): QueryEventByEventIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventByEventIdWithOptions(request, runtime);
}

/**
 * Query the event traces by the event Id
 */
async function queryEventByEventIdWithOptions(request: QueryEventByEventIdRequest, runtime: Util.RuntimeOptions): QueryEventByEventIdResponse {
  Util.validateModel(request);
  return doRequest('queryEventByEventId', 'HTTP', 'POST', `/openapi/queryEventByEventId`, null, request, null, runtime);
}

/**
 * The request of query the event traces by the event period
 */
model QueryEventsByPeriodRequest = {
  eventBusName: string(name='EventBusName'),
  eventSource?: string(name='EventSource'),
  startTime: long(name='StartTime'),
  endTime: long(name='EndTime'),
  limit: integer(name='Limit'),
  nextToken: integer(name='NextToken'),
}

/**
 * The response of query the event traces by the event period
 */
model QueryEventsByPeriodResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  tracedEvents?: [ TracedEvent ](name='TracedEvents'),
  nextToken?: string(name='NextToken'),
  total?: integer(name='Total'),
}

/**
 *Query the event traces by the event period
 */
async function queryEventsByPeriod(request: QueryEventsByPeriodRequest): QueryEventsByPeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventsByPeriodWithOptions(request, runtime);
}

/**
 * Query the event traces by the event period
 */
async function queryEventsByPeriodWithOptions(request: QueryEventsByPeriodRequest, runtime: Util.RuntimeOptions): QueryEventsByPeriodResponse {
  Util.validateModel(request);
  return doRequest('queryEventsByPeriod', 'HTTP', 'POST', `/openapi/queryEventsByPeriod`, null, request, null, runtime);
}

/**
 * The detail of EventTrace
 */
model EventTrace = {
  resourceOwnerId: string(name='ResourceOwnerId'),
  action: string(name='Action'),
  eventId: string(name='EventId'),
  eventBusName: string(name='EventBusName'),
  actionTime: string(name='ActionTime'),
}

/**
 * The request of queryEventTraces
 */
model QueryEventTracesRequest = {
  eventBusName?: string(name='EventBusName'),
  eventId?: string(name='EventId'),
}

/**
 * The response of queryEventTraces
 */
model QueryEventTracesResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventTraceList?: [ EventTrace ](name='EventTraceList'),
}

/**
 * Query the event traces by the event Id
 */
async function queryEventTraces(request: QueryEventTracesRequest): QueryEventTracesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventTracesWithOptions(request, runtime);
}

/**
 * Query the event traces by the event Id
 */
async function queryEventTracesWithOptions(request: QueryEventTracesRequest, runtime: Util.RuntimeOptions): QueryEventTracesResponse {
  Util.validateModel(request);
  return doRequest('queryEventTraces', 'HTTP', 'POST', `/openapi/queryEventTraces`, null, request, null, runtime);
}

/**
 * The request of delete event streaming
 */
model DeleteEventStreamingRequest = {
  eventStreamingName: string(name='EventStreamingName'),
}

/**
 * The response of delete event streaming
 */
model DeleteEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * delete event streaming
 */
async function deleteEventStreaming(request: DeleteEventStreamingRequest): DeleteEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventStreamingWithOptions(request, runtime);
}

/**
 * delete event streaming
 */
async function deleteEventStreamingWithOptions(request: DeleteEventStreamingRequest, runtime: Util.RuntimeOptions): DeleteEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('deleteEventStreaming', 'HTTP', 'POST', `/openapi/v2/deleteEventStreaming`, null, request, null, runtime);
}

/**
 * The request of create event streaming
 */
model GetEventStreamingRequest = {
  eventStreamingName: string(name='EventStreamingName'),
}

/**
 * The response of create event streaming
 */
model GetEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventStreamingName: string(name='EventStreamingName'),
  description: string(name='Description'),
  source: Source(name='Source'),
  filterPattern: string(name='FilterPattern'),
  sink: Sink(name='Sink'),
  runOptions: RunOptions(name='RunOptions'),
  tag: string(name='Tag'),
  status: string(name='Status'),
}

/**
 * create event streaming
 */
async function getEventStreaming(request: GetEventStreamingRequest): GetEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEventStreamingWithOptions(request, runtime);
}

/**
 * create event streaming
 */
async function getEventStreamingWithOptions(request: GetEventStreamingRequest, runtime: Util.RuntimeOptions): GetEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('getEventStreaming', 'HTTP', 'POST', `/openapi/v2/getEventStreaming`, null, request, null, runtime);
}

/**
 * The metrics of event streaming
 */
model EventStreamingMetric = {
  name?: string(name='Name'),
  tps?: double(name='TPS'),
  delayTime?: long(name='DelayTime'),
  diffOffset?: long(name='DiffOffset'),
  lastDateSyncTime?: long(name='LastDateSyncTime'),
  lastHeartBeat?: long(name='LastHeartBeat'),
  status?: string(name='Status'),
}

/**
 * The request of listEventStreamingMetrics
 */
model ListEventStreamingMetricsRequest = {
  eventStreamingNames?: [ string ](name='EventStreamingNames'),
}

/**
 * The response of listEventStreamingMetrics
 */
model ListEventStreamingMetricsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventStreamingMetrics: [ EventStreamingMetric ](name='EventStreamingMetrics'),
}

/**
 * List the metrics of event streaming
 */
async function listEventStreamingMetrics(request: ListEventStreamingMetricsRequest): ListEventStreamingMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingMetricsWithOptions(request, runtime);
}

/**
 * List the metrics of event streaming
 */
async function listEventStreamingMetricsWithOptions(request: ListEventStreamingMetricsRequest, runtime: Util.RuntimeOptions): ListEventStreamingMetricsResponse {
  Util.validateModel(request);
  return doRequest('listEventStreamingMetrics', 'HTTP', 'POST', `/openapi/v2/listEventStreamingMetrics`, null, request, null, runtime);
}

/**
 * The eventsource of event streaming
 */
model EBEventSourceEntry = {
  name: string(name='Name'),
  New: boolean(name='IsNew'),
  description: string(name='Description'),
  externalSourceType: string(name='ExternalSourceType'),
  externalSourceConfig: map[string] any(name='ExternalSourceConfig'),
}

/**
 * The request of Save and start event streaming procss
 */
model SaveAndStartEventStreamingRequest = {
  name: string(name='Name'),
  description?: string(name='Description'),
  EBEventSourceEntry?: string(name='EBEventSourceEntry'),
  filterPattern?: string(name='FilterPattern'),
  targets: [ TargetEntry ](name='Targets'),
}

/**
 * The response of Save and start event streaming procss
 */
model SaveAndStartEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventStreamingARN: string(name='EventStreamingARN'),
}

/**
 * Save and start event streaming procss
 */
async function saveAndStartEventStreaming(request: SaveAndStartEventStreamingRequest): SaveAndStartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAndStartEventStreamingWithOptions(request, runtime);
}

/**
 * Save and start event streaming procss
 */
async function saveAndStartEventStreamingWithOptions(request: SaveAndStartEventStreamingRequest, runtime: Util.RuntimeOptions): SaveAndStartEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('saveAndStartEventStreaming', 'HTTP', 'POST', `/openapi/saveAndStartEventStreaming`, null, request, null, runtime);
}

/**
 * The detail of TargetEntry
 */
model TargetEntry = {
  id: string(name='Id'),
  type: string(name='Type'),
  endpoint: string(name='Endpoint'),
  pushRetryStrategy?: string(name='PushRetryStrategy'),
  paramList?: [ EBTargetParam ](name='ParamList'),
}

/**
 * The param of EBTargetParam
 */
model EBTargetParam = {
  resourceKey: string(name='ResourceKey'),
  form: string(name='Form'),
  value?: string(name='Value'),
  template?: string(name='Template'),
}

/**
 * The response of create EventBus Rule
 */
model CreateRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  ruleARN: string(name='RuleARN'),
}

/**
 * Create an EventBus rule on Aliyun
 */
async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

/**
 * Create an EventBus rule on Aliyun
 */
async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  return doRequest('createRule', 'HTTP', 'POST', `/openapi/createRule`, null, request, null, runtime);
}

/**
 * The request of delete the rule
 */
model DeleteRuleRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
}

/**
 * The response of delete the rule
 */
model DeleteRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Deletes the specified rule.
 */
async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

/**
 * Deletes the specified rule.
 */
async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  return doRequest('deleteRule', 'HTTP', 'POST', `/openapi/deleteRule`, null, request, null, runtime);
}

/**
 * The request of disable the EventBus rule
 */
model DisableRuleRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
}

/**
 * The response of disable the EventBus rule
 */
model DisableRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Disables the specified rule
 */
async function disableRule(request: DisableRuleRequest): DisableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableRuleWithOptions(request, runtime);
}

/**
 * Disables the specified rule
 */
async function disableRuleWithOptions(request: DisableRuleRequest, runtime: Util.RuntimeOptions): DisableRuleResponse {
  Util.validateModel(request);
  return doRequest('disableRule', 'HTTP', 'POST', `/openapi/disableRule`, null, request, null, runtime);
}

/**
 * The request of enable the EventBus rule
 */
model EnableRuleRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
}

/**
 * The response of enable the EventBus rule
 */
model EnableRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Enables the specified rule
 */
async function enableRule(request: EnableRuleRequest): EnableRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableRuleWithOptions(request, runtime);
}

/**
 * Enables the specified rule
 */
async function enableRuleWithOptions(request: EnableRuleRequest, runtime: Util.RuntimeOptions): EnableRuleResponse {
  Util.validateModel(request);
  return doRequest('enableRule', 'HTTP', 'POST', `/openapi/enableRule`, null, request, null, runtime);
}

/**
 * The request of UpdateEventStreaming
 */
model UpdateEventStreamingRequest = {
  eventStreamingName: string(name='EventStreamingName'),
  description?: string(name='Description'),
  Source?: Source(name='Source'),
  filterPattern?: string(name='FilterPattern'),
  Sink?: Sink(name='Sink'),
  runOptions?: RunOptions(name='RunOptions'),
  tag?: string(name='Tag'),
}

/**
 * The response of UpdateEventStreaming
 */
model UpdateEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Update event streaming procss
 */
async function updateEventStreaming(request: UpdateEventStreamingRequest): UpdateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventStreamingWithOptions(request, runtime);
}

/**
 * create event streaming
 */
async function updateEventStreamingWithOptions(request: UpdateEventStreamingRequest, runtime: Util.RuntimeOptions): UpdateEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('updateEventStreaming', 'HTTP', 'POST', `/openapi/v2/updateEventStreaming`, null, request, null, runtime);
}

/**
 * The request of StartEventStreaming
 */
model StartEventStreamingRequest = {
  eventStreamingName: string(name='EventStreamingName'),
 
}

/**
 * The response of StartEventStreaming
 */
model StartEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * create event streaming
 */
async function startEventStreaming(request: StartEventStreamingRequest): StartEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return startEventStreamingsWithOptions(request, runtime);
}

/**
 * create event streaming
 */
async function startEventStreamingsWithOptions(request: StartEventStreamingRequest, runtime: Util.RuntimeOptions): StartEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('startEventStreaming', 'HTTP', 'POST', `/openapi/v2/startEventStreaming`, null, request, null, runtime);
}

/**
 * The request of PauseEventStreaming
 */
model PauseEventStreamingRequest = {
  eventStreamingName: string(name='EventStreamingName'),
 
}

/**
 * The response of PauseEventStreaming
 */
model PauseEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * delete event streaming
 */
async function pauseEventStreaming(request: PauseEventStreamingRequest): PauseEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseEventStreamingWithOptions(request, runtime);
}

/**
 * delete event streaming
 */
async function pauseEventStreamingWithOptions(request: PauseEventStreamingRequest, runtime: Util.RuntimeOptions): PauseEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('startEventStreaming', 'HTTP', 'POST', `/openapi/v2/pauseEventStreaming`, null, request, null, runtime);
}

/**
 * The detail of DeadLetterQueue
 */
model DeadLetterQueue = {
  arn?: string(name='Arn'),
}

/**
 * The detail of EBEventStreamingEntry
 */
model EBEventStreamingEntry = {
  eventStreamingName?: string(name='EventStreamingName'),
  description?: string(name='Description'),
  source?: Source(name='Source'),
  filterPattern?: string(name='FilterPattern'),
  sink?: Sink(name='Sink'),
  runOptions?: RunOptions(name='RunOptions'),
  tag?: string(name='Tag'),
  status?: string(name='Status'),
}

/**
 * The request of search EventStreaming
 */
model listEventStreamingsRequest = {
  namePrefix?: string(name='NamePrefix'),
  sourceType?: string(name='SourceType'),
  sinkType?: string(name='SinkType'),
  limit?: integer(name='Limit'),
  nextToken?: string(name='NextToken'),
  tag?: string(name='Tag'),
}

/**
 * The response of search EventStreaming
 */
model listEventStreamingsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventStreamings?: [ EBEventStreamingEntry ](name='EventStreamings'),
  nextToken?: string(name='NextToken'),
  total?: integer(name='Total'),
}

/**
 * create event streaming
 */
async function listEventStreamings(request: listEventStreamingsRequest): listEventStreamingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventStreamingsWithOptions(request, runtime);
}

/**
 * create event streaming
 */
async function listEventStreamingsWithOptions(request: listEventStreamingsRequest, runtime: Util.RuntimeOptions): listEventStreamingsResponse {
  Util.validateModel(request);
  return doRequest('listEventStreamings', 'HTTP', 'POST', `/openapi/v2/listEventStreamings`, null, request, null, runtime);
}

/**
 * The config of SinkOdpsParameters
 */
model SinkOdpsParameters = {
  project?: TargetParameter(name='Project'),
  table?: TargetParameter(name='Table'),
  roleName?: TargetParameter(name='RoleName'),
  format?: TargetParameter(name='Format'),
  mode?: TargetParameter(name='Mode'),
  partitionWindowType?: TargetParameter(name='PartitionWindowType'),
  timeZone?: TargetParameter(name='TimeZone'),
  useStreaming?: TargetParameter(name='UseStreaming'),
  extendConfig?: map[string] any(name='ExtendConfig'),
  }

/**
 * The config of SinkFcParameters
 */
model SinkFcParameters = {
  serviceName?: TargetParameter(name='ServiceName'),
  functionName?: TargetParameter(name='FunctionName'),
  body?: TargetParameter(name='Body'),
  qualifier?: TargetParameter(name='Qualifier'),
  invocationType?: TargetParameter(name='InvocationType'),
  batchSize?: TargetParameter(name='BatchSize'),
  extendConfig?: map[string] any(name='ExtendConfig'),
}

/**
 * The config of SinkRocketMQParameters
 */
model SinkRocketMQParameters = {
  instanceId?: TargetParameter(name='InstanceId'),
  topic?: TargetParameter(name='Topic'),
  body?: TargetParameter(name='Body'),
  properties?: TargetParameter(name='Properties'),
  keys?: TargetParameter(name='Keys'),
  tags?: TargetParameter(name='Tags'),
}

/**
 * The config of SinkKafkaParameters
 */
model SinkKafkaParameters = {
  instanceId?: TargetParameter(name='InstanceId'),
  topic?: TargetParameter(name='Topic'),
  acks?: TargetParameter(name='Acks'),
  key?: TargetParameter(name='Key'),
  value?: TargetParameter(name='Value'),
}

/**
 * The config of SinkRabbitMQParameters
 */
model SinkRabbitMQParameters = {
  instanceId?: TargetParameter(name='InstanceId'),
  virtualHostName?: TargetParameter(name='VirtualHostName'),
  targetType?: TargetParameter(name='TargetType'),
  exchange?: TargetParameter(name='Exchange'),
  routingKey?: TargetParameter(name='RoutingKey'),
  queueName?: TargetParameter(name='QueueName'),
  body?: TargetParameter(name='Body'),
  messageId?: TargetParameter(name='MessageId'),
  properties?: TargetParameter(name='Properties'),
}

/**
 * The config of SinkMNSParameters
 */
model SinkMNSParameters = {
  QueueName?: TargetParameter(name='QueueName'),
  body?: TargetParameter(name='Body'),
}

/**
 * The config of TargetParameter
 */
model TargetParameter = {
  value?: string(name='Value'),
  form?: string(name='Form'),
  template?: string(name='Template'),
}

/**
 * The config of Sink
 */
model Sink = {
  sinkMNSParameters?: SinkMNSParameters(name='SinkMNSParameters'),
  sinkRabbitMQParameters?: SinkRabbitMQParameters(name='SinkRabbitMQParameters'),
  sinkKafkaParameters?: SinkKafkaParameters(name='SinkKafkaParameters'),
  sinkRocketMQParameters?: SinkRocketMQParameters(name='SinkRocketMQParameters'),
  sinkFcParameters?: SinkFcParameters(name='SinkFcParameters'),
  sinkOdpsParameters?: SinkOdpsParameters(name='SinkOdpsParameters'),
}


/**
 * The config of RunOptions
 */
model RunOptions = {
  maximumTasks?: integer(name='MaximumTasks'),
  retryStrategy?: RetryStrategy(name='RetryStrategy'),
  errorsTolerance?: string(name='ErrorsTolerance'),
  deadLetterQueue?: DeadLetterQueue(name='DeadLetterQueue'),
}

/**
 * The config of RetryStrategy
 */
model RetryStrategy = {
  pushRetryStrategy?: string(name='PushRetryStrategy'),
  maximumEventAgeInSeconds?: integer(name='MaximumEventAgeInSeconds'),
  maximumRetryAttempts?: integer(name='MaximumRetryAttempts'),
}

/**
 * The config of Source
 */
model Source = {
  sourceMNSParameters?: SourceMNSParameters(name='SourceMNSParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='SourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='SourceRocketMQParameters'),
  sourceKafkaParameters?: SourceKafkaParameters(name='SourceKafkaParameters'),
}

/**
 * The request of createEventStreaming
 */
model CreateEventStreamingRequest = {
  eventStreamingName?: string(name='EventStreamingName'),
  description?: string(name='Description'),
  source?: Source(name='Source'),
  filterPattern?: string(name='FilterPattern'),
  sink?: Sink(name='Sink'),
  runOptions?: RunOptions(name='RunOptions'),
  tag?: string(name='Tag'),
}

/**
 * The response of createEventStreaming
 */
model CreateEventStreamingResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventStreamingARN?: string(name='EventStreamingARN'),
}

/**
 * Create event streaming procss
 */
async function createEventStreaming(request: CreateEventStreamingRequest): CreateEventStreamingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventStreamingWithOptions(request, runtime);
}

/**
 * Create event streaming procss
 */
async function createEventStreamingWithOptions(request: CreateEventStreamingRequest, runtime: Util.RuntimeOptions): CreateEventStreamingResponse {
  Util.validateModel(request);
  return doRequest('createEventStreaming', 'HTTP', 'POST', `/openapi/v2/createEventStreaming`, null, request, null, runtime);
}

/**
 * The detail of SourceRabbitMQParameters
 */
model SourceRabbitMQParameters = {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  virtualHostName: string(name='VirtualHostName'),
  queueName: string(name='QueueName'),
}

/**
 * The detail of SourceMNSParameters
 */
model SourceMNSParameters = {
  regionId?: string(name='RegionId'),
  queueName?: string(name='QueueName'),
  isBase64Decode: boolean(name='IsBase64Decode'),
}

/**
 * The detail of SourceRocketMQParameters
 */
model SourceRocketMQParameters = {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  tag?: string(name='Tag'),
  timestamp?: number(name='Timestamp'),
  offset?: string(name='Offset'),
  groupID: string(name='GroupID'),
}

/**
 * The detail of SourceKafkaParameters
 */
model SourceKafkaParameters = {
  InstanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  consumerGroup: string(name='ConsumerGroup'),
  offsetRest?: string(name='OffsetRest'),
}

/**
 * The request of createEventSource
 */
model CreateEventSourceRequest = {
  eventSourceName: string(name='EventSourceName', maxLength=127, minLength=1),
  description?: string(name='Description'),
  eventBusName: string(name='EventBusName'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='SourceRabbitMQParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='SourceMNSParameters'),
  SourceRocketMQParameters?: SourceRocketMQParameters(name='SourceRocketMQParameters'),
  }

/**
 * The response of createEventSource
 */
model CreateEventSourceResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventSourceARN?: string(name='EventSourceARN'),
}

/**
 * Creates a new event source within your account
 */
async function createEventSource(request: CreateEventSourceRequest): CreateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventSourceWithOptions(request, runtime);
}

/**
 * Creates a new event source within your account
 */
async function createEventSourceWithOptions(request: CreateEventSourceRequest, runtime: Util.RuntimeOptions): CreateEventSourceResponse {
  Util.validateModel(request);
  return doRequest('createEventSource', 'HTTP', 'POST', `/openapi/v2/createEventSource`, null, request, null, runtime);
}

/**
 * The request of deleteEventSource
 */
model DeleteEventSourceRequest = {
  eventBusName?: string(name='EventBusName'),
  eventSourceName: string(name='EventSourceName'),
}

/**
 * The response of deleteEventSource
 */
model DeleteEventSourceResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Delete the event source
 */
async function deleteEventSource(request: DeleteEventSourceRequest): DeleteEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventSourceWithOptions(request, runtime);
}

/**
 * Delete the event source
 */
async function deleteEventSourceWithOptions(request: DeleteEventSourceRequest, runtime: Util.RuntimeOptions): DeleteEventSourceResponse {
  Util.validateModel(request);
  return doRequest('deleteEventSource','HTTP', 'POST', `/openapi/v2/deleteEventSource`, null, request, null, runtime);
}

/**
 * The request of update the event source
 */
model UpdateEventSourceRequest = {
  eventSourceName: string(name='EventSourceName', maxLength=127, minLength=1),
  description?: string(name='Description'),
  eventBusName: string(name='EventBusName'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='SourceRabbitMQParameters'),
  sourceMNSParameters?: SourceMNSParameters(name='SourceMNSParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='SourceRocketMQParameters'),
} 

/**
 * The response of update the event source
 */
model UpdateEventSourceResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * Update the event source
 */
async function updateEventSource(request: UpdateEventSourceRequest): UpdateEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventSourceWithOptions(request, runtime);
}

/**
 * Update the event source
 */
async function updateEventSourceWithOptions(request: UpdateEventSourceRequest, runtime: Util.RuntimeOptions): UpdateEventSourceResponse {
  Util.validateModel(request);
  return doRequest('updateEventSource','HTTP', 'POST', `/openapi/v2/updateEventSource`, null, request, null, runtime);
}

/**
 * The request of Get EventBus
 */
model GetRuleRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
}

/**
 * The response of Get EventBus
 */
model GetRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventBusName: string(name='EventBusName'),
  ruleARN: string(name='RuleARN'),
  ruleName: string(name='RuleName'),
  description: string(name='Description'),
  status: string(name='Status'),
  filterPattern: string(name='FilterPattern'),
  targets: [ TargetEntry ](name='Targets'),
  ctime: int64(name='Ctime'),
  mtime: int64(name='Mtime'),
}

/**
 * Describes the specified rule
 */
async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

/**
 * Describes the specified rule
 */
async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  return doRequest('getRule', 'HTTP', 'POST', `/openapi/getRule`, null, request, null, runtime);
}

/**
 * The request of search EventBus
 */
model ListRulesRequest = {
  eventBusName: string(name='EventBusName'),
  ruleNamePrefix?: string(name='RuleNamePrefix'),
  limit?: integer(name='Limit'),
  nextToken?: string(name='NextToken'),
}

/**
 * The response of search EventBus
 */
model ListRulesResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  nextToken: string(name='NextToken'),
  rules: [ EventRuleDTO ](name='Rules'),
  total: integer(name='Total'),
}

/**
 * The detail of EventBuses rule
 */
model EventRuleDTO = {
  ruleARN: string(name='RuleARN'),
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
  description: string(name='Description'),
  status: string(name='Status'),
  filterPattern: string(name='FilterPattern'),
  targets: [ TargetEntry ](name='Targets'),
  ctime: int64(name='Ctime'),
  mtime: int64(name='Mtime'),
}

/**
 * List all the rules which meet the search criteria
 */
async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

/**
 * List all the rules which meet the search criteria
 */
async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  return doRequest('listRules', 'HTTP', 'POST', `/openapi/listRules`, null, request, null, runtime);
}

/**
 * The request of update the EventBus rule
 */
model UpdateRuleRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
  description?: string(name='Description'),
  status?: string(name='Status'),
  filterPattern?: string(name='FilterPattern'),
}

/**
 * The response of update the EventBus rule
 */
model UpdateRuleResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
}

/**
 * update the specified rule.
 */
async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

/**
 * update the specified rule.
 */
async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  return doRequest('updateRule','HTTP', 'POST', `/openapi/updateRule`, null, request, null, runtime);
}

/**
 * The request of create Targets
 */
model CreateTargetsRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
  targets: [ TargetEntry ](name='Targets'),
}

/**
 * The response of create Targets
 */
model CreateTargetsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  eventBusARN: string(name='EventBusARN'),
}

/**
 * Adds the specified targets to the specified rule
 */
async function createTargets(request: CreateTargetsRequest): CreateTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTargetsWithOptions(request, runtime);
}

/**
 * Adds the specified targets to the specified rule
 */
async function createTargetsWithOptions(request: CreateTargetsRequest, runtime: Util.RuntimeOptions): CreateTargetsResponse {
  Util.validateModel(request);
  return doRequest('createTargets','HTTP', 'POST', `/openapi/createTargets`, null, request, null, runtime);
}

/**
 * The request of delete Targets
 */
model DeleteTargetsRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
  targetIds: [ string ](name='TargetIds'),
}

/**
 * The response of delete Targets
 */
model DeleteTargetsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  errorEntriesCount: integer(name='ErrorEntriesCount'),
  errorEntries: [ TargetResultEntry ](name='ErrorEntries'),
}

/**
 * The result detail of target operation
 */
model TargetResultEntry = {
  errorCode: string(name='ErrorCode'),
  errorMessage: string(name='ErrorMessage'),
  entryId: string(name='EntryId'),
}

/**
 * Delete the specified targets from the specified rule
 */
async function deleteTargets(request: DeleteTargetsRequest): DeleteTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTargetsWithOptions(request, runtime);
}

/**
 * Delete the specified targets from the specified rule
 */
async function deleteTargetsWithOptions(request: DeleteTargetsRequest, runtime: Util.RuntimeOptions): DeleteTargetsResponse {
  Util.validateModel(request);
  return doRequest('deleteTargets','HTTP', 'POST', `/openapi/deleteTargets`, null, request, null, runtime);
}

/**
 * The request of search Targets
 */
model ListTargetsRequest = {
  eventBusName: string(name='EventBusName'),
  ruleName: string(name='RuleName'),
  limit?: integer(name='Limit'),
}

/**
 * The response of search Targets
 */
model ListTargetsResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  targets: [ TargetEntry ](name='Targets'),
}

/**
 * List all the Targets which meet the search criteria
 */
async function listTargets(request: ListTargetsRequest): ListTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTargetsWithOptions(request, runtime);
}

/**
 * List all the Targets which meet the search criteria
 */
async function listTargetsWithOptions(request: ListTargetsRequest, runtime: Util.RuntimeOptions): ListTargetsResponse {
  Util.validateModel(request);
  return doRequest('listTargets','HTTP', 'POST', `/openapi/listTargets`, null, request, null, runtime);
}

/**
 * The request of testEventPattern
 */
model TestEventPatternRequest = {
  event: string(name='Event', maxLength=2048),
  eventPattern: string(name='EventPattern', maxLength=2048),
}

/**
 * The response of testEventPattern
 */
model TestEventPatternResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  result: boolean(name='Result'),
}

/**
 * Tests whether the specified event pattern matches the provided event
 */
async function testEventPattern(request: TestEventPatternRequest): TestEventPatternResponse {
  var runtime = new Util.RuntimeOptions{};
  return testEventPatternWithOptions(request, runtime);
}

/**
 * Tests whether the specified event pattern matches the provided event
 */
async function testEventPatternWithOptions(request: TestEventPatternRequest, runtime: Util.RuntimeOptions): TestEventPatternResponse {
  Util.validateModel(request);
  return doRequest('testEventPattern','HTTP', 'POST', `/openapi/testEventPattern`, null, request, null, runtime);
}

/**
 * The request of query EventBridge status for a given user
 */
model QueryEventBridgeStatusRequest = {
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId', description='the accountId of resource owner'),
}

/**
 * The response of query EventBridge status for a given user
 */
model QueryEventBridgeStatusResponse = {
  requestId: string(name='RequestId'),
  resourceOwnerAccountId: string(name='ResourceOwnerAccountId'),
  defaultBusEnable: boolean(name='DefaultBusEnable'),
}

/**
 * Check the activation status of EventBridge service for a given user
 */
async function queryEventBridgeStatus(request: QueryEventBridgeStatusRequest): QueryEventBridgeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEventBridgeStatusWithOptions(request, runtime);
}

/**
 * Check the activation status of EventBridge service for a given user
 */
async function queryEventBridgeStatusWithOptions(request: QueryEventBridgeStatusRequest, runtime: Util.RuntimeOptions): QueryEventBridgeStatusResponse {
  Util.validateModel(request);
  return doRequest('queryEventBridgeStatus', 'HTTP', 'POST', `/openapi/queryEventBridgeStatus`, null, request, null, runtime);
}

/**
 * Encapsulate the request and invoke the network
 * @param action the api name
 * @param protocol http or https
 * @param method e.g. GET
 * @param pathname pathname of every api
 * @param query which contains request params
 * @param body content of request
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(action: string, protocol: string, method: string, pathname: string, query: map[string]string, body: any, headers: map[string]string, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  __request.headers = {
    date = Util.getDateUTCString(),
    host = @endpoint,
    accept = 'application/json',
    x-acs-signature-nonce = Util.getNonce(),
    x-acs-signature-method = 'HMAC-SHA1',
    x-acs-signature-version = '1.0',
    x-eventbridge-version = '2015-06-06',
    user-agent = Util.getUserAgent(' aliyun-eventbridge-sdk/1.1.0'),
    ...headers
  };

  if (!Util.isUnset(@regionId)) {
    __request.headers.x-eventbridge-regionId = @regionId;
  }

  if (!Util.isUnset(body)) {
    __request.body = Util.toJSONString(body);
    __request.headers.content-type = 'application/json; charset=utf-8';
  }

  if (Util.equalString(action, 'putEvents')) {
    __request.headers.content-type = 'application/cloudevents-batch+json; charset=utf-8';
  }

  if (Util.equalString(action, 'putEventsToAccount')) {
    __request.headers.content-type = 'application/cloudevents-batch+json; charset=utf-8';
    __request.headers.x-eventbridge-sourcetype = 'acs.*';
  }

  if (!Util.isUnset(query)) {
    __request.query = query;
  }

  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  if (!Util.empty(securityToken)) {
    __request.headers.x-acs-accesskey-id = accessKeyId;
    __request.headers.x-acs-security-token = securityToken;
  }

  var stringToSign = EventBridgeUtil.getStringToSign(__request);
  __request.headers.authorization = `acs:${accessKeyId}:${EventBridgeUtil.getSignature(stringToSign, accessKeySecret)}`;
} returns {
  var result = Util.readAsJSON(__response.body);
  var tmp = Util.assertAsMap(result);
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    throw {
      code = tmp.code,
      message = `[EventBridgeError] ${tmp.message}`,
      data = tmp,
    }
  }
  return tmp;
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}